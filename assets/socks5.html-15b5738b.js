import{_ as s,p as c,q as e,a1 as i}from"./framework-49860b1b.js";const a={},o=i('<h1 id="socks" tabindex="-1"><a class="header-anchor" href="#socks" aria-hidden="true">#</a> socks</h1><h2 id="历史" tabindex="-1"><a class="header-anchor" href="#历史" aria-hidden="true">#</a> 历史</h2><p>该协议设计之初是为了让有权限的用户可以穿过防火墙的限制，使得高权限用户可以访问一般用户不能访问的外部资源。</p><p>当时设计者考虑到几乎所有使用 TCP/IP 通信的应用软件都使用 socket（套接字）完成底层的数据通信，为了方便软件开发者使用该协议，协议设计者就刻意对应了几组 socket 编程最经典的操作，并且将该协议定名为 socks</p><p>最先被广泛使用的协议是第四版本，就是 socks4。该版本支持 TCP 的 connect（作为客户端连接）和 listen（打开一个监听端口），不支持 UDP 协议。sockes4A 作了一点增强，允许客户端将域名发送给 socks 服务器，让服务器进行域名解析。</p><h2 id="socks5-改动" tabindex="-1"><a class="header-anchor" href="#socks5-改动" aria-hidden="true">#</a> socks5 改动</h2><p>socks5 相对于第四版作了大幅度的增强</p><ul><li>增加了对 UDP 协议的支持</li><li>可以支持多种用户身份验证方式和通信加密方式</li><li>修改了 socks 服务器进行域名解析的方法</li></ul><p>socks5 于 1996 年被 IETF 确认为标准通信协议，RFC 编号为 1928</p><p>https://www.ietf.org/rfc/rfc1928.txt</p><p>https://www.ietf.org/rfc/rfc1929.txt</p><p>socks5 虽然支持多种用户身份验证方式，但是应用程序真正实现的一般只有两种：不验证和用户名密码验证。尽管从 scoks4 开始就支持打开 TCP 监听端口，但是直到 socks5 也只允许这个端口接收一个客户端连接，因此网络服务提供者（如 http 服务器）不能使用 socks5，实际上很多 socks 服务器的实现也不支持打开 TCP 监听端口。</p><h2 id="工作方式" tabindex="-1"><a class="header-anchor" href="#工作方式" aria-hidden="true">#</a> 工作方式</h2><ul><li>客户端向服务端发出代理请求</li><li>服务端应答，和客户端协商认证方式，及版本号</li><li>协商成功后，服务端向客户端发送响应</li><li>客户端向服务端发送目标端 IP 和端口</li><li>服务端和目标端建立连接</li><li>服务端将客户端发出的请求加密（sslocal 加密）后发送给目标端</li><li>服务端将目标端响应的数据发送给客户端</li><li>代理完成</li></ul>',14),t=[o];function l(r,h){return c(),e("div",null,t)}const d=s(a,[["render",l],["__file","socks5.html.vue"]]);export{d as default};
