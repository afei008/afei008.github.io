import{_ as e,p as d,q as o,R as c,a1 as i}from"./framework-49860b1b.js";const n={},a=i(`<h1 id="布局约束" tabindex="-1"><a class="header-anchor" href="#布局约束" aria-hidden="true">#</a> 布局约束</h1><h2 id="基本规则" tabindex="-1"><a class="header-anchor" href="#基本规则" aria-hidden="true">#</a> 基本规则</h2><ul><li>首先，上层 <code>widget</code> 向下层 <code>widget</code> 传递约束条件</li><li>然后，下层 <code>widget</code> 向上层 <code>widget</code> 传递大小信息</li><li>最后，上层 <code>widget</code> 决定下层 <code>widget</code> 的位置</li></ul><p>细节描述</p><ul><li>首先，<code>widget</code> 会通过它的父级获得自身的约束。约束为 4 个浮点类型的集合：最大、最小宽度，最大、最小高度</li><li>然后，这个 <code>widget</code> 会逐个遍历它的子级，向每个子级传递约束（子级之间的约束可能会不同），然后询问每个子级需要用于布局的大小</li><li>然后，这个 <code>widget</code> 会对它的每个子级逐个进行布局</li><li>最后，这个 <code>widget</code> 把它的大小信息传递给父级，包括其自身的原始约束条件</li></ul><h2 id="限制" tabindex="-1"><a class="header-anchor" href="#限制" aria-hidden="true">#</a> 限制</h2><ul><li>一个 <code>widget</code> 仅在其父级给其约束的情况下才能决定自身的大小。这意味着 <code>widget</code> 通常情况下<strong>不能任意获得其想要的大小</strong></li><li>一个 <code>widget</code> <strong>无法知道，也不需要决定其在屏幕中的位置</strong>。因为它的位置是由其父级决定的</li><li>当轮到父级决定其大小和位置的时候，同样也取决于它自身的父级。所以在不考虑整棵树的情况下，几乎不可能精确定义任何 <code>widget</code> 的大小和位置</li><li>如果子级想要拥有和父级不同的大小，然后父级没有足够的空间对其进行布局的话，子级的设置的大小可能不会生效。此时<strong>请明确指定它的对齐方式</strong></li></ul><h2 id="container" tabindex="-1"><a class="header-anchor" href="#container" aria-hidden="true">#</a> Container</h2><p><code>Container</code> 的表现</p><ul><li>以屏幕为父级，屏幕强制 <code>Container</code> 变成和屏幕一样大小，无论 <code>Container</code> 的参数如何设置</li><li>以 <code>Center</code> 为父级，此时 <code>Center</code> 变成全屏，<code>Center</code> 告诉 <code>Container</code> 可以渲染成任意大小，但是不能超出屏幕，此时 <code>Container</code> 将根据其自身的参数渲染 <ul><li>当 <code>Container</code> 的宽高为无限时，将变成和屏幕一样大小</li><li>当 <code>Container</code> 没有参数时，将变成和屏幕一样大小（这个决定是由其父级决定的，可能会因父级的不同而不同，须阅读 <code>Container</code> 的文档来理解不同常见下它的这种行为）</li><li>当 <code>Container</code> 具有 <code>padding</code> 参数时，<code>padding</code> 将被带入约束的计算中</li></ul></li><li>以 <code>Align</code> 为父级，效果与 <code>Center</code> 一样，不同的是 <code>Align</code> 默认不会剧中，且可以通过 <code>alignment</code> 参数调整位置</li><li>以 <code>ConstrainedBox</code> 为父级，因为 <code>ConstrainedBox</code> 仅对其从其父级接收到的约束下施加其他约束，此时屏幕告诉 <code>ConstrainedBox</code> 为全屏，因此它告诉 <code>Container</code> 也以屏幕大小为约束，从而忽略自身的其他参数。当 <code>ConstrainedBox</code> 被其他元素包裹时，它自身的参数将会生效，此时 <code>Container</code> 将被限制在 <code>ConstrainedBox</code> 的最大最小参数值的范围内</li><li>以 <code>UnconstrainedBox</code> 为父级，<code>UnconstrainedBox</code> 允许其子级变为任意大小，因此 <code>Container</code> 可以变为任意大小 <ul><li>当 <code>Container</code> 超出 <code>UnconstrainedBox</code> 时，将会显示溢出警告</li><li>当 <code>Container</code> 宽高为无限时，控制台将报错</li><li>当 <code>Container</code> 被 <code>LimitedBox</code> 包裹时，<code>Container</code> 的无限宽高将被忽略，被强制限制为 <code>LimitedBox</code> 的宽高</li><li><code>LimitedBox</code> 的限制参数，仅在获得无限约束时才适用，这是它与 <code>ConstrainedBox</code> 的区别</li></ul></li><li>以 <code>OverflowBox</code> 为父级，<code>OverflowBox</code> 与 <code>UnconstrainedBox</code> 类似，区别在于子级超出时不会显示溢出警告</li></ul><h2 id="fittedbox" tabindex="-1"><a class="header-anchor" href="#fittedbox" aria-hidden="true">#</a> FittedBox</h2><p><code>FittedBox</code> 的表现（以 <code>Text</code> 为子级说明）</p><ul><li>以屏幕为父级，屏幕会让 <code>FittedBox</code> 强制全屏，因此 <code>FittedBox</code> 会强制缩放 <code>Text</code>，使其占满屏幕空间</li><li>以 <code>Center</code> 为父级，此时 <code>Center</code> 让 <code>FittedBox</code> 可以变为任意大小，<code>FittedBox</code> 将会根据 <code>Text</code> 的尺寸调整自己的大小 <ul><li>当 <code>Text</code> 尺寸小于或等于屏幕大小时，不会发生缩放</li><li>当 <code>Text</code> 尺寸大于屏幕时，由于 <code>FittedBox</code> 的大小限制为屏幕大小，此时将会对 <code>Text</code> 进行缩放以适应屏幕</li></ul></li><li>当 <code>FittedBox</code> 的子级的宽高为无限时，控制台会报错</li></ul><h2 id="row" tabindex="-1"><a class="header-anchor" href="#row" aria-hidden="true">#</a> Row</h2><p><code>Row</code> 的表现</p><ul><li><code>Row</code> 与 <code>UnconstrainedBox</code> 一样不会对子级施加限制，一样会产生溢出警告</li><li>当 <code>Row</code> 的子级被包裹在 <code>Expanded</code> 之后，子级自身的宽度将被忽略</li><li>如果所有 <code>Row</code> 的子级都被 <code>Expanded</code> 包裹，每一个 <code>Expanded</code> 大小都会与其 <code>flex</code> 因子成比例，且 <code>Expanded</code> 会强制子级具有与 <code>Expanded</code> 相同的宽度</li><li><code>Flexible</code> 与 <code>Expanded</code> 类似，唯一的区别是 <code>Flexible</code> 允许其子级的宽度比它小或相等。<code>Expanded</code> 是强制相等</li></ul><h2 id="scaffold" tabindex="-1"><a class="header-anchor" href="#scaffold" aria-hidden="true">#</a> Scaffold</h2><p><code>Scaffold</code> 的表现</p><ul><li>屏幕强制 <code>Scaffold</code> 全屏，<code>Scaffold</code> 告诉其子级可以为任意大小，但是不能超出屏幕</li><li>当 <code>Scaffold</code> 的子级被 <code>SizedBox.expand</code> 包裹时，该子级将变得和 <code>Scaffold</code> 一样大</li></ul><h2 id="宽松约束-loose-和严格约束-tight" tabindex="-1"><a class="header-anchor" href="#宽松约束-loose-和严格约束-tight" aria-hidden="true">#</a> 宽松约束（loose）和严格约束（Tight）</h2><p>宽松约束就是设置了最大宽度，但其最小宽度为 0，高度也是</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code>minWidth <span class="token operator">=</span> <span class="token number">0.0</span>
manWidth <span class="token operator">=</span> size<span class="token punctuation">.</span>width
minHeight <span class="token operator">=</span> <span class="token number">0.0</span>
manHeight <span class="token operator">=</span> size<span class="token punctuation">.</span>height
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>严格约束就是最大最小宽度是一样的，高度也是</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code>minWidth <span class="token operator">=</span> size<span class="token punctuation">.</span>width
manWidth <span class="token operator">=</span> size<span class="token punctuation">.</span>width
minHeight <span class="token operator">=</span> size<span class="token punctuation">.</span>height
manHeight <span class="token operator">=</span> size<span class="token punctuation">.</span>height
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,24);function t(l,s){return d(),o("div",null,[c(" @format "),a])}const p=e(n,[["render",t],["__file","2.html.vue"]]);export{p as default};
