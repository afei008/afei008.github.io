import{_ as e,p as c,q as o,a1 as d}from"./framework-49860b1b.js";const t={},a=d('<h1 id="new-和-object-create-的区别" tabindex="-1"><a class="header-anchor" href="#new-和-object-create-的区别" aria-hidden="true">#</a> new 和 Object.create 的区别</h1><h1 id="new-做了以下操作" tabindex="-1"><a class="header-anchor" href="#new-做了以下操作" aria-hidden="true">#</a> new 做了以下操作：</h1><ul><li>创建一个全新的对象</li><li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）连接</li><li>this 会绑定到生成的新对象</li><li>通过 <code>new</code> 创建的每个对象将最终被<code>[[Prototype]]</code>连接到这个函数的 prototype 对象上</li><li>如果函数没有返回对象类型 <code>Object</code>（包含 <code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>），那么 <code>new</code> 表达式中的函数调用会自动返回这个新的对象。</li></ul><h1 id="objcet-create" tabindex="-1"><a class="header-anchor" href="#objcet-create" aria-hidden="true">#</a> Objcet.create</h1><p>创建一个新对象，使用现有的对象来作为新创建对象的原型</p><p>如果第二个参数被指定且不为 <code>undefined</code>，则该传入对象的自有可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）将为新创建的对象添加指定的属性值和对应的属性描述符。这些属性对应于 <code>Object.defineProperties()</code> 的第二个参数</p><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h1><p><code>new</code> 会继承父类的属性和原型方法，<code>Objcet.create</code> 仅会继承原型方法</p>',8),r=[a];function i(n,h){return c(),o("div",null,r)}const s=e(t,[["render",i],["__file","14.html.vue"]]);export{s as default};
