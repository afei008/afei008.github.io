import{_ as i,p as e,q as a,a1 as l}from"./framework-49860b1b.js";const r={},h=l('<h1 id="前端监控" tabindex="-1"><a class="header-anchor" href="#前端监控" aria-hidden="true">#</a> 前端监控</h1><h2 id="前端监控的目的" tabindex="-1"><a class="header-anchor" href="#前端监控的目的" aria-hidden="true">#</a> 前端监控的目的</h2><p>了解用户行为，以用户数据为基础，指导产品的优化方向</p><p>主要分为 3 大类：数据监控、性能监控、异常监控</p><h3 id="数据监控" tabindex="-1"><a class="header-anchor" href="#数据监控" aria-hidden="true">#</a> 数据监控</h3><p>即常见的埋点统计，大多数情况下使用成熟的第三方统计，主要监控的数据包括</p><ul><li>PV/UV：page view、user view，UV 是在 PV 的基础上，根据用户信息不同做了去重操作</li><li>用户在每个页面停留的时间</li><li>用户来源</li><li>用户的页面操作行为</li></ul><h3 id="性能监控" tabindex="-1"><a class="header-anchor" href="#性能监控" aria-hidden="true">#</a> 性能监控</h3><p>主要监听前端项目在用户端展示的性能，监控这些数据能够更好地优化用户体验，常见的监控数据包括</p><ul><li>首屏加载时间</li><li>HTTP 接口的响应时间</li><li>静态资源的下载时间</li></ul><h3 id="错误监控" tabindex="-1"><a class="header-anchor" href="#错误监控" aria-hidden="true">#</a> 错误监控</h3><p>在某些特殊场景下，代码会出现异常报错，可能引发线上的故障，这部分的异常如果没有监控，则只能由用户主动告知，主要监控类型包括</p><ul><li>js 代码运行错误、语法错误等</li><li>Ajax 请求错误</li><li>静态资源加载错误</li><li>promise 异步函数错误</li></ul><h2 id="错误信息采集" tabindex="-1"><a class="header-anchor" href="#错误信息采集" aria-hidden="true">#</a> 错误信息采集</h2><p>需要关注一下几项信息</p><ul><li>what：发送了什么错误，语法错误、类型错误、数据错误、逻辑错误等</li><li>when：什么时间发生</li><li>who：哪个用户或哪一类用户发生</li><li>where：哪个项目、哪些页面发生</li><li>why：为什么会发生错误，在什么场景下发生</li><li>how：怎么解决</li></ul><h2 id="错误捕获" tabindex="-1"><a class="header-anchor" href="#错误捕获" aria-hidden="true">#</a> 错误捕获</h2><h3 id="通用错误" tabindex="-1"><a class="header-anchor" href="#通用错误" aria-hidden="true">#</a> 通用错误</h3><ul><li><p>try / catch 只能捕获代码常规运行错误</p></li><li><p>window.onerror 只有返回 true 时，异常才不会向上抛出，否则控制台还是会显示 Uncaught Error</p></li><li><p>window.addEventListener(&#39;error&#39;)（与 window.onerror 基本一样，但 window.onerror 不能捕获资源加载失败） 不同浏览器下返回的 Error 对象不一样，需要做兼容处理</p><ul><li><p>能捕获</p><ul><li>常规运行错误</li><li>资源加载错误</li><li>网络请求错误，但是无法判断 HTTP 状态</li></ul></li><li><p>不能捕获</p><ul><li>promise</li><li>语法错误</li></ul></li></ul></li><li><p>window.addEventListener(&#39;unhandledrejection&#39;)</p><ul><li>用来捕获 Promise 未处理 reject ，但是返回的信息只有 promise 和 reason ，没有其他具体信息</li><li>可能发生在 window 下，也可能发生在 worker 中</li><li>如果要去掉控制台的异常显示，需要加上 event.preventDefault()</li></ul></li></ul><h3 id="vue-错误" tabindex="-1"><a class="header-anchor" href="#vue-错误" aria-hidden="true">#</a> vue 错误</h3><p>vue 会捕获到所有 vue 单文件组件或者 vue.extend 继承的代码，所以在 vue 里面出现的错误不会直接抛给 window.onerror，而是会被 vue 自身的 Vue.config.errorHandler 捕获</p><h3 id="react-错误" tabindex="-1"><a class="header-anchor" href="#react-错误" aria-hidden="true">#</a> react 错误</h3><p>react 16 提供了一个内置函数 componentDidCatch，使用它可以捕获到 react 组件内部抛出的错误信息</p><h2 id="错误上报" tabindex="-1"><a class="header-anchor" href="#错误上报" aria-hidden="true">#</a> 错误上报</h2><h3 id="img-上报" tabindex="-1"><a class="header-anchor" href="#img-上报" aria-hidden="true">#</a> img 上报</h3><p>最推荐的一种方式，通过动态的创建一个 img 标签的方式，向服务器请求资源，把上报信息通过查询参数的方式带到请求的后面</p><p>优点</p><ul><li>简单快捷</li><li>无跨域问题</li><li>无需等待服务器返回数据</li></ul><p>缺点</p><ul><li>url 长度限制，无法传输过大的参数</li></ul><h3 id="ajax-上报" tabindex="-1"><a class="header-anchor" href="#ajax-上报" aria-hidden="true">#</a> Ajax 上报</h3><p>优点</p><ul><li>可携带大量参数</li></ul><p>缺点</p><ul><li>本身是一个请求，可能存在发生异常的情况</li><li>存在跨域问题</li><li>需等待服务器返回状态码才能确定该次上报成功</li></ul>',35),d=[h];function n(t,o){return e(),a("div",null,d)}const c=i(r,[["render",n],["__file","front-end-monitor.html.vue"]]);export{c as default};
