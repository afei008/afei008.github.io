import{_ as n,p as a,q as s,a1 as e}from"./framework-49860b1b.js";const t={},p=e(`<h1 id="生命周期之间所做事情" tabindex="-1"><a class="header-anchor" href="#生命周期之间所做事情" aria-hidden="true">#</a> 生命周期之间所做事情</h1><p>本文不涉及 keep-alive 的场景和错误处理的场景</p><h2 id="初始化流程" tabindex="-1"><a class="header-anchor" href="#初始化流程" aria-hidden="true">#</a> 初始化流程</h2><h3 id="new-vue" tabindex="-1"><a class="header-anchor" href="#new-vue" aria-hidden="true">#</a> new Vue</h3><p>从 new Vue(options) 开始作为入口，Vue 只是一个简单的构造函数，内部为</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Vue</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进入_init 函数后，先初始化了一些属性，然后开始第一个生命周期</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&#39;beforeCreate&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="beforecreate-被调用完成" tabindex="-1"><a class="header-anchor" href="#beforecreate-被调用完成" aria-hidden="true">#</a> beforeCreate 被调用完成</h3><p>beforeCreate 之后</p><ul><li>初始化 inject</li><li>初始化 state <ul><li>初始化 props</li><li>初始化 methods</li><li>初始化 data</li><li>初始化 computed</li><li>初始化 initWatch</li></ul></li><li>初始化 provide</li></ul><p>然后进入 created 阶段</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&#39;create&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="create-被调用完成" tabindex="-1"><a class="header-anchor" href="#create-被调用完成" aria-hidden="true">#</a> create 被调用完成</h3><p>调用 $mount 方法，开始挂载组件到 dom 上</p><p>如果使用了 rentime-with-compile 版本，则会把你传入的 template 选项，或者 html 文本，通过一系列的编译生成 render 函数</p><ul><li>编译这个 template，生成 ast 抽象语法树</li><li>优化这个 ast，标记静态节点，即渲染过程中不会变的那些节点，优化性能</li><li>根据 ast，生成 render 函数</li></ul><p>具体对应的代码为</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>optimize <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">optimize</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果是脚手架搭建的项目的话，这一步已经由 vue-cli 做好了，所以就直接进入 mountComponent 函数</p><p>确保有了 render 函数后，就可以往渲染的步骤继续进行了</p><h3 id="beforemount-被调用完成" tabindex="-1"><a class="header-anchor" href="#beforemount-被调用完成" aria-hidden="true">#</a> beforeMount 被调用完成</h3><p>把渲染组件的函数定义好，具体代码为</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>vm._render</code> 其实就是调用上一步拿到的 render 函数生成一个 vnode</li><li><code>vm._update</code> 方法会对这个 vnode 进行 patch 操作，帮助我们把 vnode 通过 createElm 函数创建新节点并且渲染到 dom 节点中</li></ul><p>接下来就是执行这段代码，由响应式原理的一个核心类 Watcher 负责执行这个函数，因为我们需要在这段过程中去观察这个函数读取了哪些响应数据，将来这些响应式数据更新的时候，需要重新执行 updateComponent 函数</p><p>如果是更新后调用 updateComponent 函数，内部的 patch 不再是初始化时候的创建节点，而是对新旧 vnode 进行 diff，找出最小化的更新</p><p>Watcher 代码为</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>
    vm<span class="token punctuation">,</span>
    updateComponent<span class="token punctuation">,</span>
    noop<span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&#39;beforeUpdate&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此处在 before 属性上定义了 beforeUpdate 函数，也就是说在 Watcher 被响应式属性的更新触发之后，重新渲染新视图之前，会先调用 beforeUpdate 声明周期</p><p>如果在渲染过程中，遇到了子组件，则会调用 createComponent 函数，其内部会做一件事</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>Ctor <span class="token operator">=</span> baseCtor<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在普通的场景下，这就是 Vue.extend 生成的构造函数，可以理解为继承自 Vue 函数</p><p>注：vnode 也有自己的生命周期，只是平时开发接触不到</p><p>子组件会有自己的 init 周期，这个周期内部会做这样的事情</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">createComponentInstanceForVnode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
child<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>createComponentInstanceForVnode 内部会去调用子组件的构造函数</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>componentOptions<span class="token punctuation">.</span>Ctor</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个构造函数内部是这样的</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">Sub</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">VueComponent</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 <code>_init</code> 就是文章开头的那个函数，其实就是：遇到子组件，就会优先开始子组件的构建过程，从 beforeCreate 重新开始</p><p>组件之间的初始化生命周期</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>父 beforeCreate
父 create
父 beforeMount
子 beforeCreate
子 create
子 beforeMount
孙 beforeCreate
孙 create
孙 beforeMount
孙 mounted
子 mounted
父 mounted
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mounted-被调用完成" tabindex="-1"><a class="header-anchor" href="#mounted-被调用完成" aria-hidden="true">#</a> mounted 被调用完成</h3><p>组件挂载完成，初始化的生命周期结束</p><h2 id="更新流程" tabindex="-1"><a class="header-anchor" href="#更新流程" aria-hidden="true">#</a> 更新流程</h2><p>当一个响应式属性被更新后，会触发 Watcher 的回调函数，也就是 vm._update(vm._render())，在更新之前会先调用 before 属性上定义的函数</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&#39;beforeUpdate&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于 Vue 的异步更新机制，beforeUpdate 的调用已经是在 nextTick 中了，具体代码为</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">nextTick</span><span class="token punctuation">(</span>flushSchedulerQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">flushSchedulerQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        watcher <span class="token operator">=</span> queue<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>before<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            watcher<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 即 callHook(vm, &#39;beforeUpdate&#39;)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="beforeupdate-被调用完成" tabindex="-1"><a class="header-anchor" href="#beforeupdate-被调用完成" aria-hidden="true">#</a> beforeUpdate 被调用完成</h3><p>经历了一系列的 patch、diff 之后，组件重新渲染完毕，调用 update 钩子</p><p>这里对 updated 调用是倒序的，如：props 流向为父--子--孙，触发 updated 钩子为孙--子--父。具体代码为</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">callUpdatedHooks</span><span class="token punctuation">(</span><span class="token parameter">queue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> watcher <span class="token operator">=</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> vm <span class="token operator">=</span> watcher<span class="token punctuation">.</span>vm<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_watcher <span class="token operator">===</span> watcher <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>_isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&#39;updated&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="updated-被调用完成" tabindex="-1"><a class="header-anchor" href="#updated-被调用完成" aria-hidden="true">#</a> updated 被调用完成</h3><p>渲染更新流程完毕</p><h2 id="销毁流程" tabindex="-1"><a class="header-anchor" href="#销毁流程" aria-hidden="true">#</a> 销毁流程</h2><p>在更新后的 patch 过程中，如果发现有组件在下一轮渲染中消失，则会调用 removeVnodes 进入组件销毁流程</p><p>removeVnodes 会调用 vnode 的 destroy 生命周期，而 destroy 内部则会调用 vm.$destroy()（keep-alive 包裹的子组件除外）</p><p>这时会调用 callHook(vm, &#39;beforeDestroy&#39;)</p><h3 id="beforedestroy-被调用完成" tabindex="-1"><a class="header-anchor" href="#beforedestroy-被调用完成" aria-hidden="true">#</a> beforeDestroy 被调用完成</h3><p>之后会经历一系列的清理逻辑：清除父子关系、watcher 关闭等</p><p>但是 <code>$destroy</code> 并不会把组件从视图上移除，如果想要手动销毁一个组件，则需要自己去完成这个逻辑（根据官方文档解释，<code>$destroy</code> 只是清理它和其他实例的连接，以及解除指令和事件监听器，断掉虚拟 dom 和真实 dom 之间的联系，并没有真正回收这个实例，若此时浏览器已经渲染了 dom，则该 dom 可能不会被移除）</p><p>至于 vue 实例什么时候回收，其本质上是一个 js 的内存回收问题</p><p>最后调用 callHook(vm, &#39;destroyed&#39;)</p><h3 id="destroyed-被调用完成" tabindex="-1"><a class="header-anchor" href="#destroyed-被调用完成" aria-hidden="true">#</a> destroyed 被调用完成</h3><p>组件销毁完成</p>`,67),o=[p];function c(i,u){return a(),s("div",null,o)}const d=n(t,[["render",c],["__file","7.html.vue"]]);export{d as default};
