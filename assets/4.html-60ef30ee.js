import{_ as e,M as p,p as l,q as i,Q as a,t as n,N as o,a1 as t}from"./framework-49860b1b.js";const r={},d=t('<h1 id="微前端相关问题的解决思路" tabindex="-1"><a class="header-anchor" href="#微前端相关问题的解决思路" aria-hidden="true">#</a> 微前端相关问题的解决思路</h1><h2 id="价值" tabindex="-1"><a class="header-anchor" href="#价值" aria-hidden="true">#</a> 价值</h2><p>微前端架构具备以下几个核心价值</p><ul><li>技术栈无关：主框架不限制接入应用的技术栈，子应用具备完全自主权</li><li>独立开发、独立部署：子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</li><li>独立运行时：每个子应用之间状态隔离，运行时状态不共享</li></ul><p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的应用不可维护的问题，这类问题在企业级 web 应用中尤其常见</p><h2 id="针对中后台应用的解决方案" tabindex="-1"><a class="header-anchor" href="#针对中后台应用的解决方案" aria-hidden="true">#</a> 针对中后台应用的解决方案</h2><p>从技术实现角度，微前端架构解决方案大概分为两类场景</p><ul><li>单实例：即同一时刻，只有一个子应用被展示，子应用具备一个完整的应用生命周期，通常基于 url 的变化来做子应用的切换</li><li>多实例：同一时刻可以展示多个子应用，通常使用 Web Components 方案来做子应用封装，子应用更像是一个业务组件而不是应用</li></ul><p>以下将以单实例场景下来介绍微前端（基于 single-spa），因为这个场景更贴近大部分中后台应用</p><h2 id="实践中的问题" tabindex="-1"><a class="header-anchor" href="#实践中的问题" aria-hidden="true">#</a> 实践中的问题</h2><p>主框架的拼接层作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用，它的定位仅仅是：导航路由和资源加载框架</p><p>要实现这样一套架构，需要解决以下几个技术问题</p><h2 id="路由系统及-future-state" tabindex="-1"><a class="header-anchor" href="#路由系统及-future-state" aria-hidden="true">#</a> 路由系统及 Future State</h2><h3 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h3><p>当浏览器重新刷新时，主框架资源会被重新加载，同时异步 load 子应用的静态资源，由于此时主应用的路由系统已经激活，但子应用的资源可能还没有完全加载完毕，从而导致路由注册表里发现没有能匹配子应用的规则，这是会导致跳到 404 或者路由报错</p><p>该问题在所有 lazy load 方式加载子应用的方案中都会碰到，早些年 angularjs 社区把这个问题统一称为 Future State</p><h3 id="解决" tabindex="-1"><a class="header-anchor" href="#解决" aria-hidden="true">#</a> 解决</h3><p>设计一套路由机制</p><ul><li>主框架配置子应用的路由为<code>subApp: { url: &#39;/subApp/**&#39;, entry: &#39;./subApp.js&#39; }</code></li><li>当浏览器的地址为<code>/subApp/abc</code>时，框架需要先加载 entry 资源</li><li>待 entry 资源加载完毕，确保子应用的路由系统注册进主框架之后，再由子应用的路由系统接管 url change 事件</li><li>同时在子应用路由切出时，主框架需要触发响应的 destroy 事件，子应用在监听到该事件时，调用自己的卸载方法卸载应用</li></ul><h4 id="app-entry" tabindex="-1"><a class="header-anchor" href="#app-entry" aria-hidden="true">#</a> App Entry</h4><p>主框架与子应用集成的方式</p><table><thead><tr><th>方案</th><th>特点</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>构建时</td><td>子应用通过 Package Registry（或者 npm package、git tags）的方式，与主应用一起打包发布</td><td>主应用、子应用之间可以做打包优化，如依赖共享等</td><td>子应用与主应用之间产品工具链耦合，工具链也是技术栈的一部分<br>子应用每次发布依赖主应用重新打包发布</td></tr><tr><td>运行时</td><td>子应用自己构建打包，主应用运行时动态加载子应用资源</td><td>主应用与子应用完全解耦，子应用与技术栈无关</td><td>会多出一些运行时的复杂度和 overhead</td></tr></tbody></table><p>要实现真正的技术栈无关和独立部署两个核心目标，大部分情况下需要使用运行时加载子应用这种方案</p><h4 id="js-entry-和-html-entry" tabindex="-1"><a class="header-anchor" href="#js-entry-和-html-entry" aria-hidden="true">#</a> JS Entry 和 HTML Entry</h4><p>上面确定了集成方案，此处要选择子应用应该提供什么形式的资源作为渲染入口</p><table><thead><tr><th>资源形式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>HTML Entry</td><td>子应用开发、发布完全独立<br>子应用具备与独立应用开发时一致的开发体验</td><td>多一次请求，子应用资源解析消耗转移到运行时<br>主子应用不处于同一个构建环境，无法利用 bundler 的一些构建期的优化能力，如公共依赖抽取等</td></tr><tr><td>JS Entry</td><td>主子应用使用同一个 bundler，可以方便做构建时优化</td><td>子应用的发布需要主应用重新打包<br>主应用需要为每个子应用预留一个容器节点，且该节点 id 需与子应用的容器 id 保持一致<br>子应用各类资源需要一起打成一个 bundle，资源加载效率变低</td></tr></tbody></table><h2 id="模块导入" tabindex="-1"><a class="header-anchor" href="#模块导入" aria-hidden="true">#</a> 模块导入</h2><h3 id="问题-1" tabindex="-1"><a class="header-anchor" href="#问题-1" aria-hidden="true">#</a> 问题</h3><p>微前端架构下，我们需要获取到子应用暴露出的一些钩子引用，如 bootstrap、mount、unmout 等(参考 single-spa)，从而能对接入应用有一个完整的生命周期控制。而由于子应用通常又有集成部署、独立部署两种模式同时支持的需求，使得我们只能选择 umd 这种兼容性的模块格式打包我们的子应用。如何在浏览器运行时获取远程脚本中导出的模块引用也是一个需要解决的问题。</p><h3 id="解决-1" tabindex="-1"><a class="header-anchor" href="#解决-1" aria-hidden="true">#</a> 解决</h3>',30),c={href:"https://github.com/systemjs/systemjs/blob/master/src/extras/global.js",target:"_blank",rel:"noopener noreferrer"},u=t(`<h2 id="应用隔离" tabindex="-1"><a class="header-anchor" href="#应用隔离" aria-hidden="true">#</a> 应用隔离</h2><p>微前端架构方案中有两个非常关键的问题，有没有解决这两个问题将直接标志该方案是否真的生产可用</p><ul><li>样式隔离</li><li>js 隔离</li></ul><h3 id="样式隔离" tabindex="-1"><a class="header-anchor" href="#样式隔离" aria-hidden="true">#</a> 样式隔离</h3><p>在微前端场景下，不同技术栈的子应用会被集成到同一个运行时中，所以我们必须在框架层确保各个子应用之间不会出现样式互相干扰的问题</p><ul><li><p>Shadow DOM 隔离性太强，如 modal 组件，是动态挂载到 document.body 的，而 Shadow DOM 的特性导致组件的样式只会在 shadow 这个作用域下生效，结果就是弹出框无法应用样式，解决办法是把样式上浮一层，丢到主应用，但是这样着意味着子应用的样式直接泄露到主应用了</p></li><li><p>CSS Module 或者 BEM 约定 css 前缀的方式来避免样式冲突，或者直接基于 css module 方案写样式，对于全新的项目是可行的，但是微前端架构更多的目标是解决遗产应用，遗产应用通常是很难有动力做大幅改造的</p><p>最主要的是，当两个子应用都引入了第三方组件库，但该库不支持定制化前缀？或者两个子应用都引入了同一个组件库的不同版本，都写入了全局的样式，但彼此不兼容怎么办？</p></li><li><p>Dynamic Stylesheet 该方案很简单，只需要在应用切出/卸载后，同时卸载掉其样式表即可，原理是浏览器会对所有的样式表的插入、移除做整个 CSSOM 的重构，从而达到插入、卸载样式的目的，这样就能保证在同一个时间点里，只有一个应用的样式表是生效的</p><p>HTML Entry 方案天生具有样式隔离的特性，因为应用卸载后会直接移除 HTML 结构，从而自动移除了其样式表，在该方案下，子应用加载完成后的 DOM 结构可能长这样</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>subApp<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!-- 子应用完整的 html 结构 --&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>subapp.css<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>root<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当子应用被替换或卸载时，subApp 节点的 innerHTML 也会被复写，subapp.css 也就自然被移除了</p></li></ul><h3 id="js-隔离" tabindex="-1"><a class="header-anchor" href="#js-隔离" aria-hidden="true">#</a> js 隔离</h3><p>如何确保各个子应用之间的全局变量不会互相干扰，一般来说是劫持 window</p><p>通常有两种思路</p><ul><li>沙箱快照，原理是对 window 进行多次遍历，达到激活和失活的效果</li><li>proxy</li></ul><p>各个框架的实现</p><ul><li>qankun：在应用的 bootstrap 和 mount 两个生命周期开始之前分别给全局状态打下快照，然后当应用切出/卸载时，将状态回滚值 bootstrap 开始之前的阶段，确保应用对全局状态的污染全部清 0，第二次进入时再恢复至 mount 之前的状态，从而确保 remount 时拥有跟第一次 mount 时一致的全局上下文</li><li>berial：使用<code>Mutation Observer</code>侦测 document 的变化，如果变化的 target 不是当前沙箱，则对其进行劫持，然后塞回沙箱</li></ul><h1 id="框架对比" tabindex="-1"><a class="header-anchor" href="#框架对比" aria-hidden="true">#</a> 框架对比</h1><p>qiankun 与 berial</p><p>berial 使用了原生 Shadow DOM，不依赖 single-spa</p><h1 id="webpack5-module-federation" tabindex="-1"><a class="header-anchor" href="#webpack5-module-federation" aria-hidden="true">#</a> webpack5 module federation</h1><p>webpack5 的新特性，中文名叫做“模块联邦”，该特性可以实现多个不同技术栈共存，而且不需要任何框架，但目前还没支持沙箱隔离</p>`,17);function h(b,k){const s=p("ExternalLinkIcon");return l(),i("div",null,[d,a("p",null,[n("只需要走 umd 包格式中的 global export 方式获取子应用的导出即可，大体的思路是通过给 window 变量打标记，记住每次最后添加的全局变量，这个变量一般就是应用 export 后挂载到 global 上的变量，实现方式可以参考"),a("a",c,[n("systemjs global import"),o(s)])]),u])}const g=e(r,[["render",h],["__file","4.html.vue"]]);export{g as default};
