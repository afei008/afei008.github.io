import{_ as n,p as s,q as a,a1 as e}from"./framework-49860b1b.js";const p={},t=e(`<h1 id="响应式更新精确到组件级别" tabindex="-1"><a class="header-anchor" href="#响应式更新精确到组件级别" aria-hidden="true">#</a> 响应式更新精确到组件级别</h1><p>Vue 对于响应式属性的更新，只会精确更新依赖收集的<code>当前组件</code>，而不会递归的去更新子组件，这也是它性能强大的原因之一</p><h2 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h2><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
        {{ msg }}
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildComponent</span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们触发<code>this.msg = &#39;hello, world&#39;</code>的时候，会触发组件的更新，视图的重新渲染。但是<code>&lt;ChildComponent /&gt;</code>这个组件其实是不会重新渲染的，这是 Vue 刻意而为之的</p><h2 id="react-的更新粒度" tabindex="-1"><a class="header-anchor" href="#react-的更新粒度" aria-hidden="true">#</a> React 的更新粒度</h2><p>React 在类似的场景下是<code>自顶向下的进行递归更新</code>，也就是说，Reach 中的子组件不管嵌套了多少层，所有层次都会递归更新。因此 React 创造了 Fiber，创造了异步渲染（Fiber 就是把一个长时任务进行分片，并且维护每一个分片的数据结构）</p><p>React 遵从的是<code>不可变</code>的设计思想，永远不在原对象上修改属性，所以基于<code>Object.defineProperty</code>或<code>Proxy</code>的响应式依赖收集机制就无法使用。由于没有响应式依赖收集，React 只能递归的把所有子组件都重新渲染一遍（除了 memo 和 shouldComponentUpdate 等优化手段），然后再通过<code>diff算法</code>决定要更新哪部分的视图，这个递归的过程叫做<code>reconciler</code>，性能上很灾难</p><h2 id="vue-的更新粒度" tabindex="-1"><a class="header-anchor" href="#vue-的更新粒度" aria-hidden="true">#</a> Vue 的更新粒度</h2><p>Vue 的每个组件都有自己的<code>渲染watcher</code>，它掌管了当前组件的视图更新，但是并不会掌管子组件的更新</p><p>源码中，在<code>patch</code>的过程中，当组件更新到<code>ChildComponent</code>的时候，会走到<code>patchVnode</code>方法，下面看源码了解该方法做了什么事情</p><h3 id="patchvnode" tabindex="-1"><a class="header-anchor" href="#patchvnode" aria-hidden="true">#</a> patchVnode</h3><h4 id="_1-执行-vnode-的-prepatch-钩子-然后会进入到updatechildcomponent方法" tabindex="-1"><a class="header-anchor" href="#_1-执行-vnode-的-prepatch-钩子-然后会进入到updatechildcomponent方法" aria-hidden="true">#</a> 1. 执行 vnode 的 prepatch 钩子，然后会进入到<code>updateChildComponent</code>方法</h4><p>注意，只有<code>组件vnode</code>才会有<code>prepatch</code>这个生命周期</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">prepatch</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentOptions
    <span class="token comment">// 这个 child 就是子组件的 vm 实例，也就是平常用的 this</span>
    <span class="token keyword">const</span> child <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>componentInstance
    <span class="token function">updateChildComponent</span><span class="token punctuation">(</span>
        child<span class="token punctuation">,</span>
        options<span class="token punctuation">.</span>propsData<span class="token punctuation">,</span>
        options<span class="token punctuation">.</span>listeners<span class="token punctuation">,</span>
        vnode<span class="token punctuation">,</span>
        options<span class="token punctuation">.</span>children
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到做了以下 3 步</p><ul><li>更新 props</li><li>更新绑定事件</li><li>对于 slot 做一些更新</li></ul><h4 id="_2-如果有子节点的话-对子节点进行更新" tabindex="-1"><a class="header-anchor" href="#_2-如果有子节点的话-对子节点进行更新" aria-hidden="true">#</a> 2. 如果有子节点的话，对子节点进行更新</h4><p>对子节点的<code>vnode</code>利用<code>diff</code>算法来更新（具体算法本文略过）。到这里<code>patchVnode</code>就结束了</p><h4 id="_3-如果有子组件" tabindex="-1"><a class="header-anchor" href="#_3-如果有子组件" aria-hidden="true">#</a> 3. 如果有子组件</h4><p>那么在<code>diff</code>的过程中，只会对<code>component</code>上声明的<code>props</code>、<code>listeners</code>等属性进行更新，不会深入到组件内部进行更新，到这里<code>patchVnode</code>就结束了</p><h3 id="props-的更新如何触发重新渲染" tabindex="-1"><a class="header-anchor" href="#props-的更新如何触发重新渲染" aria-hidden="true">#</a> props 的更新如何触发重新渲染</h3><p>在组件初始化<code>props</code>的时候，会走到<code>initProps</code>方法，此方法主要是将<code>props</code>也变成响应式数据</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> propsOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 经过一系列验证 props 合法性的流程后</span>
    <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">validateProp</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> propsOptions<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token comment">// props 中的字段也被定义成响应式了</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当<code>msg</code>传给子组件的时候，会被保存在子组件实例的<code>_props</code>上，并且被定义成了响应式数据，而子组件的模板中对于<code>msg</code>的访问是被代理到<code>_props.msg</code>上的，只要子组件在模板里读取了这个属性，也就能精确收集到依赖</p><p>当父组件发生重渲染的时候，会重新计算子组件的<code>props</code>，具体是在<code>updateChildComponent</code>方法中（在上面的<code>prepatch</code>方法的最后，会进入到该方法）</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>propsData <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token comment">// 注意 props 被指向了 _props</span>
    <span class="token keyword">const</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span>_props
    <span class="token keyword">const</span> propKeys <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_propKeys <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> propKeys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> key <span class="token operator">=</span> propKeys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">const</span> propOptions <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props
        <span class="token comment">// 这里触发了对于 _props.msg 的依赖更新</span>
        props<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">validateProp</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> propOptions<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">toggleObserving</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>propsData <span class="token operator">=</span> propsData
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>vm.$forceUpdate</code>本质上就是触发了<code>渲染watcher</code>的重新执行，与修改一个响应式的属性触发更新的原理是一样的，都是调用了<code>vm._watcher.update()</code>，只是提供了一个便捷的 api，在设计模式中叫做<code>门面模式</code></p><p>官网的 api 文档中所说</p><blockquote><p><code>vm.$forceUpdate</code>：迫使 Vue 实例重新渲染，注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件</p></blockquote><h3 id="slot-是怎么更新的" tabindex="-1"><a class="header-anchor" href="#slot-是怎么更新的" aria-hidden="true">#</a> slot 是怎么更新的</h3><p>组件中含有<code>slot</code>的更新，是属于比较特殊的场景</p><p>假设有父组件<code>parent-comp</code></p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot-comp</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>{{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot-comp</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>子组件<code>slot-comp</code></p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的<code>msg</code>属性在进行依赖收集的时候，收集到的是<code>parent-comp</code>的<code>渲染watcher</code></p><p>假如<code>msg</code>更新了，这个组件在更新的时候遇到了一个子组件<code>slot-comp</code>，按照 Vue 的精确更新策略来说，子组件是不会重新渲染的</p><p>但是在源码内部做了一个判断，在<code>updateChildComponent</code>方法内部</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> hasChildren <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>
    <span class="token comment">// 这里就是判断 slot 元素的地方</span>
    <span class="token punctuation">(</span>renderChildren <span class="token operator">||</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_renderChildren <span class="token operator">||</span> parentVnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>scopedSlots <span class="token operator">||</span> vm<span class="token punctuation">.</span>$scopedSlots <span class="token operator">!==</span> emptyObject<span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>hasChildren<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>$slots <span class="token operator">=</span> <span class="token function">resolveSlots</span><span class="token punctuation">(</span>renderChildren<span class="token punctuation">,</span> parentVnode<span class="token punctuation">.</span>context<span class="token punctuation">)</span>
    vm<span class="token punctuation">.</span><span class="token function">$forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里调用了<code>slot-comp</code>组件上的<code>vm.$forceUpdate()</code>，因此触发了<code>slot-comp</code>的<code>渲染watcher</code></p><p>总结，这次<code>msg</code>的更新不光触发了<code>parent-comp</code>的重新渲染，也触发了拥有<code>slot</code>的子组件的重新渲染，也就是两层渲染，如果<code>slot-comp</code>内部又渲染了其他子组件，也是不会进行递归更新的（只要子组件不要再有<code>slot</code>）</p><h2 id="父子组件的更新会经历两个-nexttick-吗" tabindex="-1"><a class="header-anchor" href="#父子组件的更新会经历两个-nexttick-吗" aria-hidden="true">#</a> 父子组件的更新会经历两个 nextTick 吗</h2><p>不会</p><p>源码里<code>queueWatcher</code>里的逻辑，父组件更新的时候，全局变量<code>isFlushing</code>是<code>true</code>，所有不会等到下一个<code>tick</code>执行，而是直接推进队列里，在一个<code>tick</code>里一起执行了</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 父组件更新的 nextTick 中会执行这个，会去循环运行 queue 里的 watcher</span>
<span class="token keyword">function</span> <span class="token function">flushSchedulerQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    currentFlushTimestamp <span class="token operator">=</span> <span class="token function">getNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    flushing <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 更新父组件</span>
        watcher<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在父组件更新的过程中又触发了子组件的响应式更新，导致触发了<code>queueWatcher</code>的话，由于<code>isFlushing</code>是<code>true</code>，会这样走<code>else</code>中的逻辑，由于子组件的<code>id</code>是大于父组件的<code>id</code>的，所以会插在父组件的<code>watcher</code>之后，父组件的更新函数执行完毕后，就会执行子组件的<code>watcher</code>了，这是在同一个<code>tick</code>中的</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flushing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>watcher<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果已经刷新，则根据其 id 拼接watcher</span>
    <span class="token comment">// 如果已经超过它的 id，它将立即运行下一个</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> inndex <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id <span class="token operator">&gt;</span> watcher<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i<span class="token operator">--</span>
    <span class="token punctuation">}</span>
    queue<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> watcher<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="vue-2-6-的优化" tabindex="-1"><a class="header-anchor" href="#vue-2-6-的优化" aria-hidden="true">#</a> Vue 2.6 的优化</h2><p>把上述对于<code>slot</code>的操作又进一步优化了，简单了说，利用<code>v-slot:foo</code>语法生成的插槽，会统一被编译成函数，在子组件的上下文中执行，所以父组件不会再收集到它内部的依赖，如果父组件中没有用到 msg，更新只会影响到子组件本身，而不再是通过父组件修改<code>_props</code>来通知子组件更新了</p>`,50),o=[t];function c(i,l){return s(),a("div",null,o)}const u=n(p,[["render",c],["__file","2.html.vue"]]);export{u as default};
