import{_ as e,p as i,q as a,a1 as r}from"./framework-49860b1b.js";const l={},t=r('<h1 id="浏览器安全" tabindex="-1"><a class="header-anchor" href="#浏览器安全" aria-hidden="true">#</a> 浏览器安全</h1><h2 id="内容安全策略-csp" tabindex="-1"><a class="header-anchor" href="#内容安全策略-csp" aria-hidden="true">#</a> 内容安全策略（CSP）</h2><p>一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途。</p><p>不支持 CSP 的浏览器会忽略它，默认为网页内容使用标准的同源策略。</p><h3 id="威胁" tabindex="-1"><a class="header-anchor" href="#威胁" aria-hidden="true">#</a> 威胁</h3><ul><li>跨站脚本攻击</li><li>数据包嗅探攻击</li></ul><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h3><p>为使 CSP 可用，需要配置服务器返回头部字段：Content-Security-Policy（X-Content-Security-Policy 是旧版本写法），meta 标签也可配置</p><ul><li>响应头使用：<code>Content-Security-Policy: &lt;policy&gt;</code></li><li>meta 标签使用：<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; img-src https://*; child-src &#39;none&#39;;&quot;&gt;</code></li></ul><h3 id="响应头使用" tabindex="-1"><a class="header-anchor" href="#响应头使用" aria-hidden="true">#</a> 响应头使用</h3><p>参数 policy 是一个包含各种描述你的 CSP 策略指令的字符串，应当包含 default-src，default-src 允许指定多个源，当其他策略未指定的时候，将使用 default-src 指定的源</p><h3 id="常见示例" tabindex="-1"><a class="header-anchor" href="#常见示例" aria-hidden="true">#</a> 常见示例</h3><ul><li>所有内容均来自站点的同一个源：<code>Content-Security-Policy: default-src &#39;self&#39;;</code></li><li>允许内容来自信任的域名及其子域名：<code>Content-Security-Policy: default-src &#39;self&#39; *.trusted.com；</code></li><li>允许网页应用的用户在他们自己的内容中包含来自任何源的图片，但限制音视频需从特定源提供，所有脚本必须从特定主机服务器获取：<code>Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src: userscripts.example.com;</code></li><li>限制所有内容都要通过 SSL 方式获取：<code>Content-Security-Policy: default-src https://onlinebanking.jumbobank.com;</code></li><li>仅允许图片从任意地方加载：<code>Content-Security-Policy: default-src &#39;self&#39; *.mailsite.com; img-src *;</code></li></ul><h2 id="报告模式" tabindex="-1"><a class="header-anchor" href="#报告模式" aria-hidden="true">#</a> 报告模式</h2><p><code>Content-Security-Policy-Report-Only: &lt;policy&gt;</code>，此时 CSP 不是强制的，但任何违规行为将会报告给一个指定的 URI 地址</p><p>若普通模式与报告模式同时使用，则两者同时生效，首先查找普通模式的策略，然后再查找报告模式的策略</p><h3 id="开启违规报告" tabindex="-1"><a class="header-anchor" href="#开启违规报告" aria-hidden="true">#</a> 开启违规报告</h3><p>默认情况不会发送违规报告，需要配置 report-uri 指定 uri 地址</p><p><code>Content-Security-Policy: default-src &#39;self&#39;; report-uri http://reportcollector.example.com/collector.cgi;</code></p><h3 id="报告语法" tabindex="-1"><a class="header-anchor" href="#报告语法" aria-hidden="true">#</a> 报告语法</h3><p>JSON 对象</p><ul><li>document-uri：发生违规的文档的 URI</li><li>referrer：违规发生处的文档引用</li><li>blocked-uri：被 CSP 阻止的资源 URI</li><li>violated-directive：违反的策略名称</li><li>original-policy：在 Content-Security-Policy 中指明的原始策略</li></ul><h2 id="同源策略" tabindex="-1"><a class="header-anchor" href="#同源策略" aria-hidden="true">#</a> 同源策略</h2><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><h2 id="cookie-安全策略" tabindex="-1"><a class="header-anchor" href="#cookie-安全策略" aria-hidden="true">#</a> cookie 安全策略</h2><p>Domain：指定有效域 Path：指定有效 url Secure：只能在 ssl 和 https 的时候才会被发送到服务器 HttpOnly：限制 cookie 不能通过 js 访问</p><h2 id="沙盒框架" tabindex="-1"><a class="header-anchor" href="#沙盒框架" aria-hidden="true">#</a> 沙盒框架</h2><p>iframe</p><h2 id="csrf-跨站请求伪造" tabindex="-1"><a class="header-anchor" href="#csrf-跨站请求伪造" aria-hidden="true">#</a> csrf 跨站请求伪造</h2><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h3><p>攻击者构造网站后台某个功能接口的请求地址，通过非正常方法使得该地址自动加载</p><h3 id="防范" tabindex="-1"><a class="header-anchor" href="#防范" aria-hidden="true">#</a> 防范</h3><ul><li>客户端：对于数据库的修改请求，全部使用 post 提交，表单提交时，携带一个随机验证字段，服务器验证该字段是否有效</li><li>服务端：使用 token 验证、验证 HTTP Referer 字段</li><li>SameSite 参数，用于 Set-Cookie 响应头里面，有三种值：None、Strict、Lax（新版本浏览器默认值），用法：<code>Set-Cookie: SameSite=Strict</code><ul><li>strict：完全禁止第三方 cookie，跨站点时，任何情况下都不会发送 cookie</li><li>Lax：大多数情况下不发送 cookie，但是导航到目标网址的 get 请求除外 <ul><li>链接：<code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></li><li>预加载：<code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></li><li>get 表单：<code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></li></ul></li></ul></li></ul><h2 id="xss-跨站脚本攻击" tabindex="-1"><a class="header-anchor" href="#xss-跨站脚本攻击" aria-hidden="true">#</a> xss 跨站脚本攻击</h2><h3 id="原理-1" tabindex="-1"><a class="header-anchor" href="#原理-1" aria-hidden="true">#</a> 原理</h3><p>攻击者往网站里面插入攻击代码（输入框、URL 参数、POST 参数、Referrer、Cookie），当用户浏览该页面时，嵌入其中的 html 代码将会执行</p><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h3><h4 id="存储型" tabindex="-1"><a class="header-anchor" href="#存储型" aria-hidden="true">#</a> 存储型</h4><p>常见于带有用户保存数据的网站功能，如发帖、评论、私信等</p><ul><li>攻击者将恶意代码提交到目标网站的数据库中</li><li>用户打开目标网站时，网站服务器将恶意代码从数据库中取出，拼接再 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul><h4 id="反射型" tabindex="-1"><a class="header-anchor" href="#反射型" aria-hidden="true">#</a> 反射型</h4><p>常见于通过 URL 传递参数的功能，如搜索、跳转</p><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的 URL 时，网站服务器将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul><h4 id="dom-型" tabindex="-1"><a class="header-anchor" href="#dom-型" aria-hidden="true">#</a> DOM 型</h4><p>DOM 型中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞</p><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的 URL</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul><h3 id="防范-1" tabindex="-1"><a class="header-anchor" href="#防范-1" aria-hidden="true">#</a> 防范</h3><p>总体思路，对输入和 URL 参数进行过滤，对输出进行编码</p><ul><li>过滤输入</li><li>转义 HTML</li><li>纯前端渲染，代码与数据分离</li></ul><h3 id="其他通用防范" tabindex="-1"><a class="header-anchor" href="#其他通用防范" aria-hidden="true">#</a> 其他通用防范</h3><ul><li>设置响应头 Content-Security-Policy</li><li>控制输入长度</li><li>HttpOnly，<code>Set-Cookie: HttpOnly</code></li><li>验证码</li></ul>',51),c=[t];function d(o,h){return i(),a("div",null,c)}const s=e(l,[["render",d],["__file","2.html.vue"]]);export{s as default};
