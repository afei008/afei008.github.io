import{_ as e,p as a,q as d,R as c,a1 as o}from"./framework-49860b1b.js";const t={},r=o(`<h1 id="第-6-章-坐标系统变换" tabindex="-1"><a class="header-anchor" href="#第-6-章-坐标系统变换" aria-hidden="true">#</a> 第 6 章 坐标系统变换</h1><h2 id="translate-变换" tabindex="-1"><a class="header-anchor" href="#translate-变换" aria-hidden="true">#</a> translate 变换</h2><p><code>&lt;use&gt;</code> 标签的 <code>x</code> 和 <code>y</code> 其实是 <code>transform</code> 属性的一种简写形式</p><p><code>translate</code> 的工作原理：获取图形的网格坐标，让将其移动到画布的新位置（并不是想象中的移动某个元素）</p><blockquote><p><code>translate</code> 变换永远不会改变图形对象的网格坐标，但是它会改变网格坐标在画布上的位置</p></blockquote><h2 id="scale-变换" tabindex="-1"><a class="header-anchor" href="#scale-变换" aria-hidden="true">#</a> scale 变换</h2><p><code>scale</code> 的工作原理：将图形对象的网格坐标进行缩放，但是坐标原点位置不会改变</p><blockquote><ul><li><code>scale</code> 变换永远不会改变图形对象的网格坐标或者它的笔画宽度，但是会改变对应画布上的网格坐标的大小</li><li><code>SVG</code> 在计算形状的坐标之前，会先对坐标系统应用变换</li></ul></blockquote><h2 id="变换序列" tabindex="-1"><a class="header-anchor" href="#变换序列" aria-hidden="true">#</a> 变换序列</h2><p>一个图形对象可以做多个变换，只需要将多个变换通过空格或逗号分割，依次放入 <code>transform</code> 属性即可</p><blockquote><p>变换序列的顺序会影响最终结果</p></blockquote><h2 id="技巧-笛卡尔坐标系统转换" tabindex="-1"><a class="header-anchor" href="#技巧-笛卡尔坐标系统转换" aria-hidden="true">#</a> 技巧：笛卡尔坐标系统转换</h2><p>如果从其他系统传输数据到 <code>SVG</code>，可能需要处理使用笛卡尔坐标表示数据的矢量图形</p><p>在笛卡尔坐标系统中，原点在左下角，往上往右为正。其 <code>y</code> 轴与 <code>SVG</code> 的默认坐标系统相反。因此需要重新计算坐标，可以使用变换序列让 <code>SVG</code> 做这些工作，而不是手动处理，步骤如下</p><ul><li>在原始绘图中找到最大 <code>y</code> 坐标</li><li>将整个绘图放入 <code>&lt;g&gt;</code> 元素中</li><li>启用平移，根据最大 <code>y</code> 值向下移动坐标系统：<code>transform=&quot;translate(0, y)&quot;</code></li><li>缩放 <code>y</code> 轴 -1 倍，让它倒置翻转：<code>transform=&quot;translate(0, y) scale(1, -1)</code></li></ul><h2 id="rotate-变换" tabindex="-1"><a class="header-anchor" href="#rotate-变换" aria-hidden="true">#</a> rotate 变换</h2><p>默认坐标系统中，角度的测量是按顺时针增加，水平向右为 0 度</p><p>默认的旋转中心点（轴心点）为坐标原点 <code>(0, 0)</code></p><p><code>rotate</code> 的工作原理：旋转整个网格坐标</p><p>通常情况下我们想要的只是旋转某个图形自身而并非整个网格坐标，可以通过一系列变换实现：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>translate(centerX, centerY) rotate(angle) translate(-centerX, -centerY)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是有更简单写法可以实现</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>routate(angle, centerX, centerY)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其原理为：以指定的 <code>x</code> 和 <code>y</code> 点作为原点临时建立一个新的坐标系统执行旋转操作，然后重新建立原始坐标</p><h2 id="技巧-围绕中心点缩放" tabindex="-1"><a class="header-anchor" href="#技巧-围绕中心点缩放" aria-hidden="true">#</a> 技巧：围绕中心点缩放</h2><p><code>SVG</code> 中没有简单的方法实现围绕某个点缩放，但是可以使用一系列的变换来实现</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>translate(-centerX * (factor - 1), -centerY(factor - 1)) scale(factor)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="skewx-和-skewy-变换" tabindex="-1"><a class="header-anchor" href="#skewx-和-skewy-变换" aria-hidden="true">#</a> skewX 和 skewY 变换</h2><p>倾斜某个轴，新坐标系统的原点不会改变</p><p><code>skewX(angle)</code> 会按照指定的角度“推动”所有 <code>x</code> 坐标，<code>y</code> 坐标不会改变。<code>skewY(angle)</code> 则相反</p><h2 id="矩阵变换" tabindex="-1"><a class="header-anchor" href="#矩阵变换" aria-hidden="true">#</a> 矩阵变换</h2><p><code>matrix(a b c d e f)</code> 指定一个 6 个值组成的矩阵变换，前面的所有变换都是矩阵变换的简写语法，但是矩阵变换难度较高，请参考本书附录 D 或其他相关资料</p><h2 id="css-变换和-svg" tabindex="-1"><a class="header-anchor" href="#css-变换和-svg" aria-hidden="true">#</a> CSS 变换和 SVG</h2><p><code>CSS</code> 的变换比较熟悉了，此处列举一下 <code>SVG</code> 变换的注意点</p><ul><li><code>SVG1.1</code> 变换使用用户单位和隐式角度（不需要指定角度单位，默认单位为“角度”）</li><li><code>SVG1.1</code> 变换是结构型属性</li><li><code>SVG</code> 中旋转原点只是 <code>rotate()</code> 函数的一部分，并且不能为缩放指定原点</li></ul>`,35);function i(l,n){return a(),d("div",null,[c(" @format "),r])}const h=e(t,[["render",i],["__file","6.html.vue"]]);export{h as default};
