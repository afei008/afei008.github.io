import{_ as e,p as i,q as l,a1 as a}from"./framework-49860b1b.js";const d={},o=a('<h1 id="mvvm-与-mvc" tabindex="-1"><a class="header-anchor" href="#mvvm-与-mvc" aria-hidden="true">#</a> MVVM 与 MVC</h1><h2 id="mvvm" tabindex="-1"><a class="header-anchor" href="#mvvm" aria-hidden="true">#</a> MVVM</h2><p>MVVM 是 Model-View-ViewModel 的简写，本质上是 MVC（Model-View-Controller）的改进版，即模型-视图-视图模型。</p><ul><li>模型：后端传递的数据</li><li>视图：前端所看到的页面</li><li>视图模型：mvvm 模式的核心，连接 view 和 model 的桥梁，有两个方向，两个方向都实现的，称之为数据的双向绑定 <ul><li>将模型转化成视图：将数据转化成页面，通过数据绑定实现</li><li>将视图转化成模型：将页面转化成数据，通过 DOM 事件监听</li></ul></li></ul><p>总结：在 MVVM 的框架下，视图和模型是不能直接通信的，它们通过 ViewModel 来通信。ViewModel 通常要实现一个观察者，当数据发生变化时，ViewModel 能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel 也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定</p><h2 id="mvc" tabindex="-1"><a class="header-anchor" href="#mvc" aria-hidden="true">#</a> MVC</h2><p>MVC 是 Model View Controller 的简写，即模型-视图-控制器，C 指的是页面业务逻辑，MVC 是单向通信，V 和 M 必须通过 C 来承上启下</p><p>ViewModel 存在的目的在于抽离 C 中的业务逻辑，其他视图操作等业务还是放在 C 中实现。在以前，业务逻辑是由后端实现的，因此可以理解为，VM 是 C 的实例</p>',8),r=[o];function t(c,M){return i(),l("div",null,r)}const n=e(d,[["render",t],["__file","9.html.vue"]]);export{n as default};
